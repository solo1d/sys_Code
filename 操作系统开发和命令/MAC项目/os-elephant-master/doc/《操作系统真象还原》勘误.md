# 《操作系统真象还原》勘误


0.2你想研究到什么程度
...略
比如乘法是基于加法，我们研究3*4等于多少，必须要承认4+4+4等于12，并认为其为真理，不用再去质疑4+4+4为什么等于12了，这就是我们的公设，至于为什么4+4+4等于12，还是由专门研究基础科学的学者们去探究吧。
...略

（注：0.14小节错误是由操作系统开发群里的小康康同学发现）
0.14为什么linux系统下的应用程序不能在windows系统下运行（以下是本小节修改后的完整内容）
	您看，linux和windows都是运行在x86体系架构cpu上的操作系统，也就是指令的机器码都是一样的，为什么linux系统下的应用程序不能在windows系统下运行呢？其实，windows下的程序也无法直接在linux下运行。
对于这个问题，很多同学都会马上给出答案:格式不同！其实。。。。答对啦，哈哈，确实是格式不同，不过这只是一方面，还有另一方面，系统API不同，API即Application Programming Interface，应用程序编程接口。
先说说格式，格式也可称为协议，协议是指：在某个固定的位置有固定意义的数据。比如偏移量为A字节、连续大小为B字节的空间中，存放的是数据C，像mysql协议、http协议都是类似这样的组织形式。一般特定于某个应用程序的文件只能被那个应用程序打开，原因是只有那个程序“懂”这个文件，如何“懂”呢？应用程序在生成文件时，一般都会在文件的开始部分写一段固定格式的数据，也就是元信息，这段数据称为文件头，故文件头是某个应用程序为自己埋下的伏笔，应用程序需要从文件头中获取文件的信息以方便它解析该文件。比如视频播放软件可通过读取视频文件的文件头来提前了解视频的信息，以选择合适的播放模式。这种“应用程序”和“被解析文件”的关系同样适用于操作系统和可执行程序，可执行程序是被操作系统识别并加载的。
Linux下的可执行程序格式是elf，也就是 “Executable and Linking Format。平时咱们用readelf命令可以查看elf文件头，里面有节（section）信息，段（segment）信息，程序入口（entry_point），哪个段由哪些节组成等等信息。而windows下的可执行程序是PE格式（“portable executable”，可移植的可执行文件），因为我没了解过，所以具体文件头咱们就不关注了，有兴趣的同学自行查看。说到这您也懂了，如果文件可以被多种应用程序解析的话，这个文件的格式必须被多种应用程序接受，即所有的应用程序都要认得这种格式的文件，比如一个视频文件可以被多种播放器播放原因正是如此。linux程序不能在windows下运行，说白了就是人家windows不认linux文件的格式。如果windows肯支持elf文件格式，那么linux程序在windows下运行也是可能的，但是…，还没完，还有另外一个“硬伤”，这就是操作系统API不同。
操作系统是通过API为应用程序提供功能支持的，一般是通过软中断指令int，再加上一个中断向量号来实现，这也称为系统调用。Linux是通过“int 0x80”来实现系统调用的，而windows是通过“int 0x2e” 来实现的，也就是说，两个操作系统下的应用程序获得操作系统功能的方式不同，同样一句机器指令“int 0x80”，在linux下就是进入内核以获得操作系统的功能支持，结果是符合预期的，而在windows下却是另一翻景象，获得的结果也许是空难性的。所以，双方的应用程序显然是不能在对方的系统中运行。
除以上原因外，这还和编译器、标准库有关，不再列举。






（注：0.17小节的错误是由操作系统开发群里的小康康同学发现）
0.17先有的语言还是先有的编译器，第1个编译器是怎么产生的。（“...略”以下至本小节结束都是重写的部分）
...略
编译器是靠不断学习，不断积累才发展起来的，这是自我学习的过程，下面来看看他们是如何让编译器长大的。
我们都知道转义字符，转义字符是以’\’开头的多个字符，通常表示某些控制字符，它们通常是不可键入的，也就是这些字符无法在键盘上直接输入，比如’\n’表示回车换行，’\t’表示tab。由于以’\’开头的字符表示转义，因此要想表示’\’字符本身，就约定用’\’来转义自己，即’\\’表示字符’\’。转义字符虽然表示的是单个字符的意义，在编译器眼里转义字符是多个字符组成的字符串，比如’\n’是字符’\’和’n’组成的字符串，好啦，交待完毕。
起初的c编译器中并没有处理转义字符，为叙述方便，我们现在称之为老编译器。如果待编译的代码文件中有字符串’\\’，这在老编译器眼里就是’\\’字符串，并不是转义后的单个字符’\’。为了表明编译器与做为其输入的代码文件的关系，我们称“做为输入的代码文件”为应用程序文件，尽管被编译的代码文件是实现了一个编译器，而在编译器眼里，它只是一个应用程序级的角色。例如，gcc –c a.c中，a.c就是应用程序文件。
	现在想在编译器中添加对转义字符的支持，那就需要修改老编译器的源代码，假设老编译器的源代码文件名为compile_old.c。被修改后的编译器代码，已不属于老编译器的源代码，故我们命名其文件名为compile_new_a.c，下面是修改后的内容。
代码compile_new_a.c

其中，函数next()的功能是返回待处理文本（即被编译的源码文件）中的下一字符，强调一下是“单个字符”，并不是记法分析中的单词（即token）。
用老编译器将新编译器的源代码compile_new_a.c编译，生成可执行文件，该文件就是新的编译器，我们取名为新编译器_a。为了方便理清他们的关系，将他们列入表格中。
编译器自身源代码	编译器	应用程序源代码	输出文件名
compile_old.c	老编译器	compile_new_a.c	新编译器_a，支持’\\’

这下编译出来的新编译器_a可以编译含有转义字符’\\’的应用程序代码了，也就是说，待编译的文件（也就是应用程序代码）中，应该用’\\’来表示’\’。而单独的字符’\’在新编译器_a中未做处理而无法通过编译。所以此时新编译器_a是无法编译自己的源代码compile_new_a.c的，因为该源文件中只是单个’\’字符，新编译器_a只认得’\\’。
先更新他们的关系，见下表。
编译器自身源代码	编译器	应用程序源代码	输出文件名
compile_old.c	老编译器	compile_new_a.c	新编译器_a，支持’\\’
compile_new_a.c	新编译器_a	compile_new_a.c	编译失败

也就是说，现在新编译器_a，无法编译自己的源文件compile_new_a.c，只有老编译器才能编译它。再啰嗦一下，新编译器_a无法正确编译自己的源文件compile_new_a.c的原因是，compile_new_a.c中’\’字符应该用转义字符的方式来引用，即所有用’\’的地方都应该替换为’\\’。再回头看一下新编译器_a的源代码compile_new_a.c，它只处理了字符串’\\’，单个’\’没有对应的处理逻辑。下面修改代码，将新修改后的代码命名为compile_new_b.c。
代码 compile_new_b.c

其实compile_new_b.c只是更新了转义字符的语法，这是新编译器_a所支持的新的语法，下面还是以新编译器_a来编译新的编译器。
用新编译器_a编译此文件，将生成新编译器_b，将新的关系录入到表格中。
编译器自身源代码	编译器	应用程序源代码	输出文件名
compile_old.c	老编译器	compile_new_a.c	新编译器_a，支持’\\’
compile_new_a.c	新编译器_a	compile_new_a.c	编译失败
compile_new_a.c	新编译器_a	compile_new_b.c	新编译器_b，支持’\\’
继续之前啰嗦两句：用编译器去编译另一编译器的源码，也许有的同学觉得很费解，其实您把“被编译的编译器源码”当成普通的应用程序源码就特别容易理解了。上面的编译器代码compile_new_b.c，其第3、6、7行的字符串’\\’被新编译器_a处理后，会以单字符’\’来代替（这是新编译器_a源码中return语句的功能），因此最终处理完成后的代码等同于代码compile_new_a.c。
现在想加上换行符’\n’的支持：

由于现在编译器还不认识’\n’，故这样做肯定不行，不过可以用其ascii码来代替，将其命名为compile_new_c.c。
代码compile_new_c.c


用新编译器_a来编译compile_new_c.c，将生成新编译器_c，新编译器_c的代码相当于代码compile_new_c.c中所有’\\’被替换为’\’后的样子，如下所示，暂且称之为代码compile_new_c1.c：
代码compile_new_c1.c


编译器自身源代码	编译器	应用程序源代码	输出文件名
compile_old.c	老编译器	compile_new_a.c	新编译器_a，支持’\\’
compile_new_a.c	新编译器_a	compile_new_a.c	编译失败
compile_new_a.c	新编译器_a	compile_new_b.c	新编译器_b，支持’\\’
compile_new_a.c	新编译器_a	compile_new_c.c	新编译器_c，间接支持“\n”

最后再修改compile_new_c.c为compile_new_d.c，将10用’\n’替代。
代码compile_new_d.c

用新编译器_c编译compile_new_d.c，生成新编译器d，将直接识别’\n’。同理，新编译器d的代码相当于代码compile_new_d.c中，所有字符串’\\’被替换为字符’\’、字符’\n’被替换为数字10后的样子，即等同于代码compile_new_c1.c。
编译器自身源代码	编译器	应用程序源代码	输出文件名
compile_old.c	老编译器	compile_new_a.c	新编译器_a，支持’\\’
compile_new_a.c	新编译器_a	compile_new_a.c	编译失败
compile_new_a.c	新编译器_a	compile_new_b.c	新编译器_b，支持’\\’
compile_new_a.c	新编译器_a	compile_new_c.c	新编译器_c，间接支持“\n”
compile_new_c.c	新编译器_c	compile_new_d.c	新编译器d，直接支持“\n”

编译器经过这样不断的训练，功能越来越强大，不过体积也越来越大了。

(感谢群里的月鸟发现此错误)
0.20 bios中断、dos中断、linux中断区别
在计算机系统中，无论是在实模式还是在保护模式，在任何情况下都会有来自外部或内部的事件发生。如果事件来自于cpu内部就称为异常，即Exception.如，cpu在计算算法时，发现分母为0，就抛出了除0异常。如果事件来自于外部，也就是该事件由外部设备发出并通知了cpu，这个事件就称为中断。




(感谢群里的月鸟发现此错误)

0.25 指令集、体系结构、微架构、编程语言
…略
	咱们拿表达式A=B+C为例。假设A、B、C都是内存变量的值，它们的地址分别0x300c、0x3004、0x3008。在此用Ra表示寄存器A，Rb表示寄存器B，Rc表示寄存器C。
完成这个加法的步骤是先将B和C载入到Rb和Rc寄存器中，再将两个寄存器的值相加后送入寄存器Ra，之后再将寄存器Ra的值写入到地址为0x300c的内存中。
…略


(感谢群里的月鸟发现此错误)
0.26库函数是用户进程与内核的桥梁
…略
大家这下应该明白了，我们在程序中简单地一句include <标准头文件>之所以有效，是因为编译器提供的c运行时库中已经为我们准备好了这些标准函数的函数体所在的目标文件，在链接时默默帮我们链接上了。
...略
1.	用户程序可以不和操作系统打交道，但如果需要操作系统的支持，必须要通过系统调用，它是用户进程和操作系统之间的“钩子”，用户进程顶多算是个半成品，只有通过钩子挂上了操作系统，加上了所需要的操作系统的那部分代码，用户程序才能做完一件事，这才算完整，后面章节会有详解。
2.	尽管系统调用是封装在库函数中，但用户程序可以直接调用“系统调用”，不过用库函数会比较高效（后面章节会有详解）。


(感谢群里的月鸟发现此错误)

0.28 MBR、EBR、DBR或OBR各是什么？
...略
现在总结一下：
EBR与MBR结构相同，但位置和数量都不同，整个硬盘只有1个MBR，其位于整个硬盘最开始的扇区——0盘0道1扇区。而EBR可有无数个，具体位
...略


(感谢群里的月鸟发现此错误)

1.3操作系统的宿主环境。
操作系统虽然是软件，但其可不是一般的软件。我们平时写出来的程序都是基于操作系统之上，程序本身是由操作系统支持的，开发人员只要专注于自己这块业
...略


(感谢群里的月鸟发现此错误)

2.2.1实模式下的1M内存布局
...略
表1-1 实模式下的内存布局
起始	结束	大小	用途
FFFF0	FFFFF	16B	BIOS入口地址，此地址也属于BIOS代码，同样属于顶部的640K字节。只是为了强调其入口地址才单独贴出来。此处16字节的内容是跳转指令jmp f000:e05b
F0000	FFFEF	64K-16B	系统BIOS范围是F0000~FFFFF共64K，为说明入口地址，将最上面的16字节从此处去掉了，所以此处终止地址是0XFFFEF。
C8000	EFFFF	160K	映射硬件适配器的ROM或内存映射式I/O
C0000	C7FFF	32K	显示适配器BIOS
B8000	BFFFF	32K	用于文本模式显示适配
器
B0000	B7FFF	32K	用于黑白显示适配器
A0000	AFFFF	64K	用于彩色显示适配器
9FC00	9FFFF	1K	EBDA (Extended BIOS Data Area)扩展bios数据区
7E00	9FBFF	622080 B 约608K	可用区域
7C00	7DFF	512B	MBR被BIOS加载到此处，共512字节
500	7BFF	30464B 约30K	可用区域
400	4FF	256B	BIOS Data Area (BIOS数据区)
000	3FF	1K	Interrupt Vector Table (中断向量表)
...略



(感谢群里的月鸟发现此错误)

2.2.2 bios是如何苏醒的
...略
如果大家不了解内存的分段访问机制，可以参考第0章，里面有讲解cpu为什么采用分段方式访问内存。说正事，cpu访问内存是用段地址+偏移地址来实现的，由于在实模式之下，段地址需要乘以16后才能与偏移地址相加，求出的和便是物
...略



(感谢群里的月鸟发现此错误)

2.2.3为什么是0x7c00
...略
0x10中断是最为强大的bios中断了，调用的方法是把功能号送入ah寄存器，其它参数按照bios中断手册的要求放在适当的寄存器中，随后执行int 0x10即可。我们不用太细致琢磨bios功能调用了，大家可以参考代码中的注释了解下即可，毕竟咱们这里用bios中断只是临时的，以后也用不到了。
...略
此项指定块的大小，dd是以块为单位来进行IO操作的，得告诉人家块是多大字节。此项是统一配置了输入块大小ibs和输出块大小obs。这两个可以单独配置。
...略



(感谢群里的月鸟发现此错误)

2.3.3请下一位选手MBR同学做准备
有点不好意思了，说了好久，才说到实质性的东西，好了，赶紧给客官上菜。
代码2-1（c2/a/boot/mbr.S）
...略
 46    ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略
 47    mov cx, 5            ; cx 为串长度,不包括结束符0的字符个数
 48    mov ax, 0x1301   ;子功能号13是显示字符及属性,要存入ah寄存器,
 49                ; al设置写字符方式 al=01: 显示字符串,光标跟随移动
...略

...略



(感谢群里的月鸟发现此错误)

3.2.4 实模式下cpu内存寻址方式
...略
第二条指令中，由于使用了段跨越前缀fs，0x5678的段基址则变成了fs寄存器。最终的内存地址是fs寄存器的值*16+0x5678，cpu到此内存地址取值再存入ax寄存器。
...略
	内存寻址
以上两种寻址方式，操作数一个是在寄存器中，一个是在指令中直接给出。它们都不在内存中。操作数在内存中的寻址方式称为内存寻址。
cpu中有很多寄存器，有些是程序员不可见的，它们是为了cpu正常运行而存在的，属于cpu运行框架内的需求。cpu给程序员用的寄存器并不是很多，所以操作数一多起来的时候，基本就捣腾不开了。内存空间相对就大多了，于是cpu工程师们自然而然想到了用内存来存储操作数。另外，用立即数寻址，得提前知道立即数是多少，否则还真用不了。而且，大多数时候操作数是位于内存中的某个位置，只知道操作数所在的内存地址，不知道操作数的值，更谈不上将其变成立即数用在指令中了，这就更加有理由让内存寻址成为“应该”。
由于访问内存是用“段基址：段内偏移地址”的形式，特别强调一下，此形
...略

	基址寻址
基址寻址，就是在操作数中用bx寄存器或bp寄存器做为地址的起始，地址的变化以它为基础。注意看啦，这里说的是只能用bx或bp做为基址寄存器。用寄存器做为内存寻址，在实模式下就是这样的，必须用bx或bp寄存器。到了保护模式下就没这个限制了，基址寄存器可选择的很多，可以是全部的通用寄存器。
...略
再看个用bp寄存器做为基址寄存器的例子，前面说过啦，用bp寄存器做偏移地址时，其默认的段寄存器是SS。这就是说，bp是用来访问栈的。为什么已经有了sp寄存器来“专门”访问栈，还要再单独准备个bp呢。sp寄存器是做为栈顶指针，相当于栈中数据的游标，这是专门给push指令和pop指令做导航用的寄存器，push指令往哪个内存压入数据，pop将哪个地址的数据弹出栈，都要看sp的值是多少。在实模式下，cpu字长是16，所以实模式下的push指令默认情况下是压入2字节的数据，其工作原理可以分为两步，假如执行push ax：
1 sub sp,2			先将sp的值减去
2 mov [sp],ax		再将ax的值mov到新的sp指向的内存。（此处纸质版与多加了个“加”字）
实模式下pop指令，其工作原理也分为两步，假如执行pop ax：
1 mov ax, [sp]		先将sp指向的值mov到ax
2 add sp,2			再将sp的指针+2.

...略
下面是堆栈框架的指令。
3  push ebp     ;将ebp压入栈，栈中备份ebp的值，占用4字节。
4  mov ebp, esp  ;将esp的值复制到ebp，ebp做为堆栈框架的基址，可用于对栈中的局部变量和其它参数寻址。（此处纸质版写成movebp）
...略



(感谢群里的月鸟发现此错误，以下全是)

3.5.3 硬盘控制器端口
...略
硬盘中的扇区在物理上是用“柱面-磁头-扇区”来定位的（Cylinder Head Sector）简称为CHS，但每次我们要事先算出扇区是在哪个盘面，哪个柱面上,这太麻烦了，这对于磁头来说很直观，它就是根据这些信息来定位扇区的。可是咱们还是希望有一套对人来说较直观的寻址方法，我们希望磁盘中扇区从0开始依次递增编号，不用考虑扇区所在的物理结构。其实我在描述需求时已经说出了LBA的定义，这是一种逻辑上为扇区编址的方法，全称为逻辑块地址（Logical Block Address）。

...略


图3-31 device寄存器（原图中的23改为了24）
...略
3.6.1改造MBR
...略
由于MBR是占据了硬盘的第0扇区（以逻辑LBA方式，扇区从0开始编号，若是以物理CHS方式，扇区则从1开始编号），第1扇区是空闲的，可以用，但离得太近总感觉不如隔开一点心里踏实，所以把loader放到第2扇区。MBR从第2扇区中把它读出来。读出来放到哪里呢？原则上是找个空闲地方就行了，在“表2-1 实模式下的内存布局”中查看下，只要在“用途”列中注明“可用区域”的地方都可以用。0x500~0x7BFF和0x7E00~9FBFF这两段内存区域都可以。
...略

代码3-5（project/c3/b/boot/mbr.S）

 ...原代码略
102 ;第4步：检测硬盘状态
103   .not_ready:
104       ;同一端口，写时表示写入命令字，读时表示读入硬盘状态
105       nop
106       in al,dx
107       and al,0x88  ;第3位为1表示硬盘控制器已准备好数据传输，
                      ;第7位为1表示硬盘忙
108       cmp al,0x08
109       jnz .not_ready       ;若未准备好，继续等。
110
111 ;第5步：从0x1f0端口读数据
...原代码略

...略

第102~109行是检测status寄存器的BSY位。由于status寄存器依然是0x1f7端口，所以不需要再为dx重新赋值。105行的nop表示空操作，即什么了也不做，只是为了增加延迟，相当于sleep了一小下，目的是减少打扰硬盘的工作。对同一端口在读写两种操作时有不同的用途，在读硬盘时，此端口中的值是硬盘的工作状态。第106行是将Status寄存器的值读入到al寄存器，通过第107行的and“与”操作，保留第3位和第7位，第3位若为1，表示数据已经准备好，可以传输了。若第7位为1，表示硬盘现在正忙着。只要判断第3位是否为1就好了，用第108行的cmp指令和0x08做减法运算，判断第3位是否为1。cmp指令并不改变操作数的值，只是根据结果去设置标志位，从而咱们根据标志位反着去判断结果。cmp指令会影响的标志位有ZF，CF，PF等，这里咱们借助ZF位来判断cmp的结果。于是用第109行的jnz .not_ready来判断结果是否不等于0，即若等于0，则status寄存器的第3位为1，这表示只可以读数据了。若不等于0，说明status寄存器的第4位为0，表示硬盘正忙（此时status寄存器第7位肯定为1）。.not_ready是个标号，于是跳回去继续判断硬盘状态，直到硬盘把数据准备好才跳出这个循环。


4.2.1 保护模式之寄存器扩展
...略
不过呢，按理说，段基址就应该是内存段的起始地址，不应该先经过处理才能用。之前实模式下的段基址之所以先要乘以16，那是因为单独的一个16位寄存器无法访问全部的1M空间，限于当时的cpu已经成型了，为了避免“推翻重
...略
于是，1985年推出了首款32位处理器80386，它的地址总线和寄存器都是32位的。结果如图4-2中的80386段描述符缓冲寄存器结构的base部分，这是个32位的段基址，位于该结构的第32~63位。这样，段基址是32位，单独的
...略

4.2.3 保护模式之运行模式反转
...略
要说段跨越前缀这个好懂，操作数反转前缀这个是干吗的呢？我们之前其实说过N多次了，模式之间可以互相使用对方环境下的资源。比如，16位实模式下可以用32位保护模式下的寄存器。但这种福利的得来却是稍费功夫的，如果要用另一模式下的操作数大小，需要在指令前添加指令前缀0x66，将当前模式临时改变成另一模式。这就是反转的意义，不管当前模式是什么，总是转变成相反的运行模式。
...略
第3行用到了32位寄存器eax，属于32位操作数，由于当前模式是16位，所以要用0x66将操作数大小转为32位。故机器码是66B834120000。其中34120000是另一操作数，B8是操作码，0x66便是操作数反转前缀。
第4行表示让编译器将第5、6行编译成32位机器码。
第5行是16位指令，但当前已在32位模式下，所以要用操作数反转前缀0x66来临时将当前模式的32位操作数反转成16位大小的操作数。故机器码是66B83412。最前面的0x66正是反转前缀,B8、3412分别是操作码和操作数。
...略

4.2.4 保护模式之指令扩展
...略
mul指令是无符号数相乘指令，指令格式是mul 寄存器/内存。
其中“寄存器/内存”是乘数。
如果乘数是8位，则把寄存器al当做另一个乘数，结果便是16位，存入寄存器ax。
如果乘数是16位，则把寄存器ax当做另一个乘数，结果便是32位，存入寄存器dx:ax，其中dx是结果的高16位，ax是结果的低16位。
如果乘数是32位，则把寄存器eax当做另一个乘数，结果便是64位，存入edx:eax，其中edx是积的高32位，eax是积的低32位。
...略



(感谢群里的さくら发现此错误)
4.3.1段描述符

表4-10中非系统段的R和C列位置互换、W和E列位置互换，即：

表4-10 段描述符的type类型
系统段	系统段类型	第3~0位	说明
		3	2	1	0
	未定义	0	0	0	0	保留
	可用的80286 TSS	0	0	0	1	仅限286的任务状态段。
	LDT	0	0	1	0	局部描述符表，只有第1位为1。
	忙碌的80286 TSS	0	0	1	1	仅限286。type中的第1位称为B位，若为1，则表示当前任务忙碌。由cpu将此位置1。
	80286调用门	0	1	0	0	仅限286。
	任务门	0	1	0	1	任务门在现代操作系统中很少用到。
	80286中断门	0	1	1	0	仅限286。
	80286陷阱门	0	1	1	1	仅限286。
	未定义	1	0	0	0	保留
	可用的80386TSS	1	0	0	1	386以上cpu的TSS，type第3位为1。
	未定义	1	0	1	0	保留
	忙碌的80386 TSS	1	0	1	1	386以上cpu的TSS，type第3位为1。
	80386调用门	1	1	0	0	386以上cpu的调用门，type第3位为1。
	未定义	1	1	0	1	保留
	中断门	1	1	1	0	386以上cpu的中断门
	陷阱门	1	1	1	1	386以上cpu的陷阱门
对于非系统段，按代码段和数据段划分，这4位分别有不同的意义。
非系统段	内存段类型	X	C	R	A	说明
	代码段	1	0	0	*	只执行代码段
		1	0	1	*	可执行、可读代码段
		1	1	0	*	可执行、一致性代码段
		1	1	1	*	可执行、可读、一致性代码段
	内存段类型	X	E	W	A	说明
	数据段	0	0	0	*	只读数据段
		0	0	1	*	可读写数据段
		0	1	0	*	只读，向下扩展的数据段
		0	1	1	*	可读写，向下扩展的数据段



4.3.5 让我们进入保护模式
...略
流水线是cpu为提高效率而采取的一种工作方式，cpu将当前指令及其后面的几条指令同时放在流水线中重叠执行。由于在实模式下时，指令是按照16位指令格式来译码，第78~82行既有16位指令又有32位指令，所以流水线把32位指令按照16位译码就会出错。解决这问题的方法就是用无条件跳转指令清空流水线。
...略
第83~89行，是用选择子初始化成各段寄存器。
	第91行，是往显存第80个字符的位置（第2行首字符的位置）写入字符P。





(感谢群里的月鸟发现此错误)
5.3.4 elf文件实例分析
本节中的p_entry都改为e_entry，0xc0101500都改为0xc0001500，如下：
...略
由这三个已经知条件，至少能看出两件事：
	前两个已知条件，能看出程序的入口虚拟地址（e_entry）0xc0001500跨过了第一个段的开头部分（p_vaddr）0xc0001000，还超过了0x500字节，这总让咱们放点心了，至少不是把elf_header也当做代码执行啦。
...略
.text表示，下面开始定义代码，所以从第2行的.text看出，main.c被确实被汇编成了代码段，由gcc编译在第3行将_start导出为全局符号，并在第4行声明_start是个函数。方框中的第5~7行是一些准备工作，属于堆栈框架的例行公事，之前咱们也提到过它，之前也说过以后会讲，不过不是现在，还没到时候。相信我，以后咱们会结合实例讲述它的，目前咱们不管它啦。重点是第8~9行的标号和代码，jmp .L2。它们就是对应于c语言中的while(1)。



5.4.6 rpl的前世今生
...略   p244
数值上CPL≤DPL并且RPL≤DPL



page204 图5-24中第4条虚拟地址映射信息有误。与代码不符合

page306 各个短描述符的Type字段数值有问题，居然会有D！！

page317 L2~L1错误，应为L2~L0
page318 OCW3中PR错误，应为RR
page340 第三行，相关信息，不是相信信息



page453 第三行病句

page463 倒数第二行方向错误

page508 图11-9错误,实为11-12
page512 图11-15错误,实为11-17
