arm汇编

> **初始化时默认sp栈指针从0开始 增长, 启动代码存储空间只有4KB**

```assembly
@ 是注释
@ arm 的PC指针 默认 +8 参与运算,  因为流水线( 取值0, 译码4, 运行8)

@跳转
bl    @调用函数方法, 执行完成后 会返回原位置 开始执行.(关键是隐式的 mov pc,lr  @这个lr是 bl的下条指令地址)
b     @调用函数方法, 与 bl  相同, 只不过不会返回,与goto相同
bx    @原有的模式进行跳转


@清位运算
bic   r0, r0, #0xf     @ r0 = r0 &(~0xf);  将r0的 低4位清0

@与运算
orr   r0, r0, 0xd3   @与运算  r0= r0 || 0xd3


@取地址值
ldr  r0, #0xf    @ r0= *(0xf); 取 0xf 内存位置中的值
ldr  r0, =r1     @ r0= r1    ; 跟mov 功能相同
ldr  r0,[r1]     @ r0= *(r1) ; r1寄存器里面存储的是个地址, 取到这个地址内存储的值

ldr  pc, abc    @跳转到 0x0f处 开始执行, 由下面两行代码设定的
abc: .word xyz      @abc 等于标号 xyz 的执行位置地址
xyz: mov r0, #0x01  @将 0x01放入r0 寄存器

ldr pc, def       @跳转到 0x100 处开始执行
def: .word 0x100


@设置字节对齐
.align 4   @设置4字节对齐

@定义
.weak ers   @如果链接器发现在别处有 ers 的定义,那么就使用那个, 这个作废

@放入
mrs  r0, cpsr   @将cpsr寄存器的值 放入 r0 寄存器

```



### 协处理器语法

```assembly
@协处理器语法
@从 cp15 中的读取数据
mrc  p15, 0, r0, c1, c0, 0    @read CP15 SCTRL Register

@ 解读:  将cp15的寄存器 c1 的值读取后放入 arm 的 r0 寄存器
@    p15  指的是cp15 协处理器
@    0    协处理特定操作码 ,cp15 就是0
@    r0   接收数据的 arm 寄存器
@    c1   协处理器cp15 的目标寄存器, c1寄存器存在于cp15协处理内
@    c0   协处理器附加的目标寄存器 或 原操作数寄存器, 如果不需要设置附加信息时, 将这设置为c0 即可
@    0    协处理器特定操作码, 用来区分同一个编号的不用物理寄存器, 不需要提供附加信息时,  指定为0




@向 cp15 中写入数据
mcr  p15, 0, r0, c1, c0, 0    

@ 将 arm r0 的值写入 cp15 协处理器的 c1 寄存器
```

